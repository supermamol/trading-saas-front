=====> src/App.css :
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}
=====> src/index.css :
html, body, #root {
  height: 100%;
  margin: 0;
}

.container-panel {
  height: 100%;
  box-sizing: border-box;
  border: 1px solid #999;
  background: #fafafa;
  padding: 8px;
}
=====> src/model/tab.ts :
/**
 * Tab
 * ---
 * Repr√©sente une unit√© de contenu m√©tier.
 * Un tab est toujours contenu dans exactement un container.
 */

 import type { TabId } from "./ids";

 export interface Tab {
   id: TabId;
 
   /**
    * Type m√©tier du contenu
    * (strategyDetail, chart, run, nodered, etc.)
    */
   kind: string;
 
   /**
    * Donn√©es m√©tier optionnelles
    * (strategyId, instanceKey, etc.)
    */
   payload?: Record<string, unknown>;
 }
 =====> src/model/container.ts :
import type { TabId, ContainerId } from "./ids";
import type { Tab } from "./tab";

/**
 * ContainerId
 * ---
 * Identifiant stable d‚Äôun container
 */

/**
 * Container
 * ---
 * - contient une pile LIFO de tabs
 * - poss√®de toujours un tab actif
 */
export interface Container {
  id: ContainerId;

  /**
   * Pile LIFO des tabs
   * - dernier √©l√©ment = tab actif
   */
  tabs: Tab[];
}

/* ======================================================
 * Invariants (documentaires, non cod√©s ici)
 * ======================================================
 *
 * - tabs.length >= 1
 * - tabs[tabs.length - 1] est le tab actif
 * - un TabId n‚Äôappara√Æt qu‚Äôune seule fois dans le workspace
 */

/* ======================================================
 * Op√©rations pures sur Container
 * ====================================================== */

/**
 * Ajoute un tab en haut de pile (devient actif)
 */
export function pushTab(
  container: Container,
  tab: Tab
): Container {
  return {
    ...container,
    tabs: [...container.tabs, tab],
  };
}

/**
 * Retire un tab du container
 * (peut √™tre le tab actif ou non)
 */
export function removeTab(
  container: Container,
  tabId: TabId
): Container {
  const nextTabs = container.tabs.filter(t => t.id !== tabId);

  if (nextTabs.length === 0) {
    throw new Error(
      `Invariant violation: container ${container.id} cannot be empty`
    );
  }

  return {
    ...container,
    tabs: nextTabs,
  };
}

/**
 * Active un tab existant
 * (LIFO: on le remonte en haut de pile)
 */
export function activateTab(
  container: Container,
  tabId: TabId
): Container {
  const tab = container.tabs.find(t => t.id === tabId);
  if (!tab) {
    throw new Error(`Tab ${tabId} not found in container ${container.id}`);
  }

  const without = container.tabs.filter(t => t.id !== tabId);

  return {
    ...container,
    tabs: [...without, tab],
  };
}
=====> src/model/workspace.ts :
/* ======================================================
 * Invariants Workspace
 * ======================================================
 *
 * - un TabId n‚Äôexiste que dans un seul container
 * - un container ne peut pas √™tre vide
 * - un container avec 1 tab est valide
 * - toute op√©ration est atomique
 */

import type { Container } from "./container";
import { pushTab, removeTab } from "./container";

import type { TabId, ContainerId } from "./ids";
import type { Tab } from "./tab";

/**
 * Workspace
 * ---
 * √âtat global du syst√®me de tabs
 */
export interface Workspace {
    containers: Record<ContainerId, Container>;
}

/* ======================================================
 * S√©lecteurs
 * ====================================================== */

export function findContainerByTab(
    workspace: Workspace,
    tabId: TabId
): Container | undefined {
    return Object.values(workspace.containers)
        .find(c => c.tabs.some(t => t.id === tabId));
}

/* ======================================================
 * Op√©rations m√©tier (atomiques)
 * ====================================================== */

/**
 * D√©place un tab d‚Äôun container source vers un container cible
 * (tab -> ent√™te)
 */
 export function moveTabToContainer(
    workspace: Workspace,
    tab: Tab,
    targetContainerId: ContainerId
  ): Workspace {
    const source = findContainerByTab(workspace, tab.id);
    if (!source) {
      throw new Error(`Source container not found for tab ${tab.id}`);
    }
  
    const target = workspace.containers[targetContainerId];
    if (!target) {
      throw new Error(`Target container ${targetContainerId} not found`);
    }
  
    const nextTarget = pushTab(target, tab);
  
    // Cas 1Ô∏è‚É£ : le container source avait > 1 tab
    if (source.tabs.length > 1) {
      const nextSource = removeTab(source, tab.id);
  
      return {
        containers: {
          ...workspace.containers,
          [source.id]: nextSource,
          [target.id]: nextTarget,
        },
      };
    }
  
    // Cas 2Ô∏è‚É£ : le container source avait 1 tab ‚Üí auto‚Äëdissolution
    const { [source.id]: _, ...rest } = workspace.containers;
  
    return {
      containers: {
        ...rest,
        [target.id]: nextTarget,
      },
    };
  }
  

/**
 * Isole un tab
 * (tab -> hors ent√™te)
 *
 * - cr√©e un nouveau container
 * - retire le tab de son container source
 */
function removeContainer(
    workspace: Workspace,
    containerId: ContainerId
): Workspace {
    const { [containerId]: _, ...rest } = workspace.containers;
    return { containers: rest };
}

/**
 * Ferme un tab
 *
 * - si le container contient > 1 tab ‚Üí retrait simple
 * - si le container contient 1 tab ‚Üí destruction du container
 */
export function closeTab(
    workspace: Workspace,
    tabId: TabId
): Workspace {
    const source = findContainerByTab(workspace, tabId);
    if (!source) {
        throw new Error(`Tab ${tabId} not found`);
    }

    if (source.tabs.length > 1) {
        const nextSource = removeTab(source, tabId);
        return {
            containers: {
                ...workspace.containers,
                [source.id]: nextSource,
            },
        };
    }

    // source.tabs.length === 1
    return removeContainer(workspace, source.id);
}

/**
 * Isole un tab
 *
 * - si le container source contient > 1 tab ‚Üí isolation
 * - sinon ‚Üí fermeture du tab
 */
 export function isolateTab(
    workspace: Workspace,
    tab: Tab,
    newContainerId: ContainerId
  ): Workspace {
    const source = findContainerByTab(workspace, tab.id);
    if (!source) {
      throw new Error(`Source container not found for tab ${tab.id}`);
    }
  
    if (source.tabs.length === 1) {
      // isolation impossible ‚Üí fermeture
      return closeTab(workspace, tab.id);
    }
  
    const nextSource = removeTab(source, tab.id);
  
    const newContainer: Container = {
      id: newContainerId,
      tabs: [tab],
    };
  
    return {
      containers: {
        ...workspace.containers,
        [source.id]: nextSource,
        [newContainerId]: newContainer,
      },
    };
  }

=====> src/model/dnd.ts :
import type { Workspace } from "./workspace";

import type { TabId } from "./ids";
import type { ContainerId } from "./ids";

import {
  moveTabToContainer,
  isolateTab,
  closeTab,
  findContainerByTab,
} from "./workspace";

/* ======================================================
 * Types DnD
 * ====================================================== */

export type DropTarget =
  | {
      type: "header";
      containerId: ContainerId;
    }
  | {
      type: "outside";
    };

/* ======================================================
 * Intention DnD ‚Üí Action m√©tier
 * ====================================================== */

/**
 * Point d‚Äôentr√©e UNIQUE pour le Drag & Drop
 *
 * Le DnD exprime une intention,
 * le mod√®le d√©cide de l‚Äôeffet r√©el.
 */
export function handleTabDrop(
  workspace: Workspace,
  tabId: TabId,
  target: DropTarget
): Workspace {
  const source = findContainerByTab(workspace, tabId);
  if (!source) {
    throw new Error(`Source container not found for tab ${tabId}`);
  }

  const tab = source.tabs.find(t => t.id === tabId);
  if (!tab) {
    throw new Error(`Tab ${tabId} not found`);
  }

  switch (target.type) {
    case "header": {
      // tab -> ent√™te
      return moveTabToContainer(
        workspace,
        tab,
        target.containerId
      );
    }

    case "outside": {
      // tab -> hors ent√™te
      // le mod√®le d√©cide : isolation OU fermeture
      return isolateTab(
        workspace,
        tab,
        generateContainerId()
      );
    }
  }
}

let containerSeq = 0;

function generateContainerId(): ContainerId {
  containerSeq += 1;
  return `container-${containerSeq}`;
}

=====> src/model/__tests__/workspace.spec.ts :
import { describe, it, expect } from "vitest";
import type { Workspace } from "../workspace";
import type { Container } from "../container";
import type { Tab } from "../tab";
import { handleTabDrop } from "../dnd";

/* ======================================================
 * Helpers de test
 * ====================================================== */

function tab(id: string): Tab {
  return { id, kind: "test" };
}

function container(id: string, tabs: Tab[]): Container {
  return { id, tabs };
}

function workspace(containers: Container[]): Workspace {
  return {
    containers: Object.fromEntries(
      containers.map(c => [c.id, c])
    ),
  };
}

/* ======================================================
 * Tests
 * ====================================================== */

describe("DnD tab-centric model", () => {

    it("tab ‚Üí ent√™te : groupement (auto-dissolution source)", () => {
        const ws = workspace([
          container("C1", [tab("A")]),
          container("C2", [tab("B")]),
        ]);
      
        const next = handleTabDrop(ws, "A", {
          type: "header",
          containerId: "C2",
        });
      
        // C1 a √©t√© auto-dissous
        expect(next.containers["C1"]).toBeUndefined();
      
        // C2 contient maintenant B + A
        expect(next.containers["C2"].tabs.map(t => t.id))
          .toEqual(["B", "A"]);
      });
      

  it("tab ‚Üí hors ent√™te (container > 1) : isolation", () => {
    const ws = workspace([
      container("C1", [tab("A"), tab("B")]),
    ]);

    const next = handleTabDrop(ws, "B", {
      type: "outside",
    });

    const containers = Object.values(next.containers);

    expect(containers.length).toBe(2);

    const isolated = containers.find(c =>
      c.tabs.some(t => t.id === "B")
    )!;

    expect(isolated.tabs.map(t => t.id)).toEqual(["B"]);
  });

  it("tab ‚Üí hors ent√™te (container = 1) : fermeture", () => {
    const ws = workspace([
      container("C1", [tab("A")]),
    ]);

    const next = handleTabDrop(ws, "A", {
      type: "outside",
    });

    expect(Object.keys(next.containers).length).toBe(0);
  });

  it("container √† 1 tab reste valide", () => {
    const ws = workspace([
      container("C1", [tab("A"), tab("B")]),
    ]);

    const next = handleTabDrop(ws, "B", {
      type: "outside",
    });

    const remaining = Object.values(next.containers)
      .find(c => c.tabs.some(t => t.id === "A"));

    expect(remaining).toBeDefined();
    expect(remaining!.tabs.map(t => t.id)).toEqual(["A"]);
  });
});
=====> src/model/__tests__/Workspace-AD-DebugView.spec.tsx :
import { render, screen, fireEvent } from "@testing-library/react";
import { useState } from "react";
import { describe, it, expect } from "vitest";

import { WorkspaceADDebugView } from "../../ui/Workspace-AD-DebugView";
import type { Workspace } from "../../model/workspace";

function TestHost() {
  const [workspace, setWorkspace] = useState<Workspace>({
    containers: {},
  });

  return (
    <WorkspaceADDebugView
      workspace={workspace}
      setWorkspace={setWorkspace}
    />
  );
}

describe("Workspace-AD-DebugView", () => {
  it("detaches a panel from its container", () => {
    render(<TestHost />);

    fireEvent.click(screen.getByText("Open Chart S1"));
    fireEvent.click(screen.getByText("Open Chart S1"));

    // on a bien 2 tabs
    expect(screen.getAllByText(/detach/i).length).toBe(2);

    // detach du premier
    fireEvent.click(screen.getAllByText("detach")[0]);

    // il n'en reste plus qu'un
    expect(screen.getAllByText(/detach/i).length).toBe(1);
  });
});
=====> src/model/__tests__/workspace.detach.spec.ts :
// workspace.detach.spec.ts
import { describe, it, expect } from "vitest";
import { openPanel, detachPanel } from "../workspace.panels";

import type { Workspace } from "../workspace";
import type { Container } from "../container";
import type { Tab } from "../tab";

/* =========================================================
 * Helpers de test (align√©s mod√®le r√©el)
 * ======================================================= */

function emptyWorkspace(): Workspace {
  return { containers: {} };
}

function containers(ws: Workspace): Container[] {
  return Object.values(ws.containers);
}

function containerCount(ws: Workspace): number {
  return containers(ws).length;
}

function allTabs(ws: Workspace): Tab[] {
  return containers(ws).flatMap(c => c.tabs);
}

function findTab(ws: Workspace, tabId: string): Tab | undefined {
  return allTabs(ws).find(t => t.id === tabId);
}

/* =========================================================
 * Tests ‚Äî openPanel
 * ======================================================= */

describe("openPanel", () => {
  it("cr√©e un container si aucun compatible n'existe", () => {
    const ws0 = emptyWorkspace();

    const ws1 = openPanel(ws0, "Chart", { strategyId: "S1" });

    expect(containerCount(ws1)).toBe(1);

    const c = containers(ws1)[0];
    expect(c.tabs.length).toBe(1);
    expect(c.groupKey).toEqual({
      kind: "Chart",
      strategyId: "S1",
    });
  });

  it("regroupe les panels par GroupKey", () => {
    let ws = emptyWorkspace();

    ws = openPanel(ws, "Chart", { strategyId: "S1" });
    ws = openPanel(ws, "Chart", { strategyId: "S1" });

    expect(containerCount(ws)).toBe(1);
    expect(containers(ws)[0].tabs.length).toBe(2);
  });

  it("ne m√©lange pas des panels de contextes diff√©rents", () => {
    let ws = emptyWorkspace();

    ws = openPanel(ws, "Chart", { strategyId: "S1" });
    ws = openPanel(ws, "Chart", { strategyId: "S2" });

    expect(containerCount(ws)).toBe(2);
  });
});

/* =========================================================
 * Tests ‚Äî detachPanel
 * ======================================================= */

describe("detachPanel", () => {
  it("retire le tab du workspace", () => {
    let ws = emptyWorkspace();
    ws = openPanel(ws, "Chart", { strategyId: "S1" });

    const tab = allTabs(ws)[0];

    const result = detachPanel(ws, tab);
    const ws2 = result.workspace;

    expect(findTab(ws2, tab.id)).toBeUndefined();
    expect(result.detached.kind).toBe("Chart");
    expect(result.detached.context.strategyId).toBe("S1");
  });

  it("supprime le container s'il devient vide", () => {
    let ws = emptyWorkspace();
    ws = openPanel(ws, "Run", { strategyId: "S1" });

    const tab = allTabs(ws)[0];

    const { workspace: ws2 } = detachPanel(ws, tab);

    expect(containerCount(ws2)).toBe(0);
  });
});

/* =========================================================
 * Tests ‚Äî retour d'un panel d√©tach√©
 * ======================================================= */

describe("return detached panel", () => {
  it("revient via openPanel (pas de restauration de position)", () => {
    let ws = emptyWorkspace();
    ws = openPanel(ws, "Chart", { strategyId: "S1" });

    const tab = allTabs(ws)[0];
    const { workspace: ws2, detached } = detachPanel(ws, tab);

    const ws3 = openPanel(ws2, detached.kind, detached.context);

    expect(containerCount(ws3)).toBe(1);
    expect(containers(ws3)[0].tabs.length).toBe(1);
  });
});
=====> src/model/ids.ts :
export type TabId = string;
export type ContainerId = string;
=====> src/model/workspace.panels.ts :
/* ======================================================
 * Workspace Panels
 * ======================================================
 *
 * Couche d‚Äôorchestration m√©tier AU‚ÄëDESSUS des tabs.
 *
 * Responsabilit√©s :
 * - openPanel (logique m√©tier + GroupKey)
 * - detachPanel (sortie vers fen√™tre)
 * - retour via openPanel
 *
 * Ne g√®re PAS :
 * - layout
 * - Mosaic
 * - UI
 */

import type { Workspace } from "./workspace";
import type { Tab } from "./tab";
import type { ContainerId } from "./ids";

/* ======================================================
 * Types m√©tier Panels
 * ====================================================== */

export type PanelKind =
  | "Strategies"
  | "StrategyDetail"
  | "Chart"
  | "Run"
  | "Nodered";

export type PanelContext = {
  strategyId?: string;
};

export type DetachedPanel = {
  kind: PanelKind;
  context: PanelContext;
};

/* ======================================================
 * API publique (√† impl√©menter)
 * ====================================================== */

/**
 * Ouvre un panel selon les r√®gles m√©tier :
 * - calcul GroupKey
 * - regroupement ou cr√©ation
 * - d√©l√®gue aux op√©rations sur tabs
 */
 import { pushTab } from "./container";
 import type { Container } from "./container";
 import type { Tab } from "./tab";
 import type { ContainerId } from "./ids";
 
 let nextContainerId = 1;
 let nextTabId = 1;
 
 function makeTab(kind: PanelKind, context: PanelContext): Tab {
   return {
     id: `tab-${nextTabId++}` as any,
     kind,
     context,
   } as Tab;
 }
 
 function groupKeyFor(kind: PanelKind, context: PanelContext) {
   return {
     kind,
     strategyId: context.strategyId,
   };
 }
 
 export function openPanel(
   workspace: Workspace,
   kind: PanelKind,
   context: PanelContext
 ): Workspace {
   const tab = makeTab(kind, context);
   const groupKey = groupKeyFor(kind, context);
 
   // 1Ô∏è‚É£ chercher un container compatible
   const existing = Object.values(workspace.containers).find(
     c =>
       c.groupKey?.kind === groupKey.kind &&
       c.groupKey?.strategyId === groupKey.strategyId
   );
 
   if (existing) {
     const next = pushTab(existing, tab);
     return {
       containers: {
         ...workspace.containers,
         [existing.id]: next,
       },
     };
   }
 
   // 2Ô∏è‚É£ cr√©er un nouveau container
   const containerId = `container-${nextContainerId++}` as ContainerId;
 
   const newContainer: Container = {
     id: containerId,
     groupKey,
     tabs: [tab],
   };
 
   return {
     containers: {
       ...workspace.containers,
       [containerId]: newContainer,
     },
   };
 }
 
 /**
 * D√©tache un panel :
 * - retire le tab du workspace
 * - ne laisse aucun container vide
 * - retourne la description m√©tier du panel d√©tach√©
 */
  import { findContainerByTab, isolateTab, closeTab } from "./workspace";
  import type { Tab } from "./tab";
  import type { Workspace } from "./workspace";
  
  export function detachPanel(
    workspace: Workspace,
    tab: Tab
  ): {
    workspace: Workspace;
    detached: { kind: any; context: any };
  } {
    const source = findContainerByTab(workspace, tab.id);
    if (!source) {
      throw new Error(`Tab ${tab.id} not found in workspace`);
    }
  
    // description m√©tier du panel d√©tach√©
    const detached = {
      kind: tab.kind,
      context: tab.context,
    };
  
    // cas 1 : le container contient plusieurs tabs ‚Üí isolation
    if (source.tabs.length > 1) {
      const nextWorkspace = isolateTab(
        workspace,
        tab,
        `detached-${tab.id}` as any
      );
  
      // le container cr√©√© par isolateTab doit √™tre supprim√©
      const { [`detached-${tab.id}` as any]: _, ...rest } =
        nextWorkspace.containers;
  
      return {
        workspace: { containers: rest },
        detached,
      };
    }
  
    // cas 2 : le container ne contient qu‚Äôun tab ‚Üí fermeture simple
    const nextWorkspace = closeTab(workspace, tab.id);
  
    return {
      workspace: nextWorkspace,
      detached,
    };
  }
  =====> src/ui/Workspace-AD-DebugView.tsx :
// src/ui/Workspace-AD-DebugView.tsx

import type { Workspace } from "../model/workspace";
import type { Tab } from "../model/tab";

import { openPanel, detachPanel } from "../model/workspace.panels";
import { closeTab } from "../model/workspace";

type Props = {
  workspace: Workspace;
  setWorkspace: (ws: Workspace) => void;
};

export function WorkspaceADDebugView({ workspace, setWorkspace }: Props) {
  return (
    <div style={{ fontFamily: "monospace", padding: 12 }}>
      <h3>Workspace ‚Äì AD Debug View</h3>

      {/* Actions explicites de test */}
      <div style={{ marginBottom: 12 }}>
        <button
          onClick={() =>
            setWorkspace(
              openPanel(workspace, "Chart", { strategyId: "S1" })
            )
          }
        >
          Open Chart S1
        </button>{" "}
        <button
          onClick={() =>
            setWorkspace(
              openPanel(workspace, "Run", { strategyId: "S2" })
            )
          }
        >
          Open Run S2
        </button>
      </div>

      {/* Projection brute du Workspace */}
      {Object.values(workspace.containers).map(container => (
        <div
          key={container.id}
          style={{
            border: "1px solid #aaa",
            marginBottom: 8,
            padding: 8,
          }}
        >
          <div>
            <strong>
              Container {container.id} | groupKey:{" "}
              {container.groupKey.kind}
              {container.groupKey.strategyId
                ? `:${container.groupKey.strategyId}`
                : ""}
            </strong>
          </div>

          <ul>
            {container.tabs.map(tab => (
              <li key={tab.id}>
                Tab {tab.id} ({tab.kind}
                {tab.context.strategyId
                  ? `, ${tab.context.strategyId}`
                  : ""}
                )
                {" "}
                <button
                  onClick={() =>
                    handleDetach(tab, workspace, setWorkspace)
                  }
                >
                  detach
                </button>{" "}
                <button
                  onClick={() =>
                    setWorkspace(closeTab(workspace, tab.id))
                  }
                >
                  x
                </button>
              </li>
            ))}
          </ul>
        </div>
      ))}
    </div>
  );
}

/* ======================================================
 * Helper local ‚Äî aucun m√©tier ici
 * ==================================================== */

function handleDetach(
  tab: Tab,
  workspace: Workspace,
  setWorkspace: (ws: Workspace) => void
) {
  const { workspace: next } = detachPanel(workspace, tab);
  setWorkspace(next);
}
=====> src/ui/Workspace-AD-View.tsx :
import type { Workspace } from "../model/workspace";
import { openPanel, detachPanel } from "../model/workspace.panels";
import { closeTab } from "../model/workspace";

import { ContainerView } from "./ContainerView";

type Props = {
  workspace: Workspace;
  setWorkspace: (ws: Workspace) => void;
};

export function WorkspaceView({ workspace, setWorkspace }: Props) {
  return (
    <div>
      <h2>Workspace</h2>

      <button
        onClick={() =>
          setWorkspace(
            openPanel(workspace, "Chart", { strategyId: "S1" })
          )
        }
      >
        Open Chart S1
      </button>

      <button
        onClick={() =>
          setWorkspace(
            openPanel(workspace, "Run", { strategyId: "S2" })
          )
        }
      >
        Open Run S2
      </button>

      <hr />

      {Object.values(workspace.containers).map(container => (
        <ContainerView
          key={container.id}
          container={container}
          onCloseTab={(tabId) =>
            setWorkspace(closeTab(workspace, tabId))
          }
          onDetachTab={(tab) => {
            const { workspace: ws2 } = detachPanel(workspace, tab);
            setWorkspace(ws2);
          }}
        />
      ))}
    </div>
  );
}
=====> src/ui/TabView.tsx :
// src/ui/TabView.tsx
import type { Tab } from "../model/tab";
import type { ContainerId } from "../model/ids";

export function TabView({
  tab,
  containerId,
  onClose,
  onDetach,
}: {
  tab: Tab;
  containerId: ContainerId;
  onClose: (tabId: string) => void;
  onDetach: (tab: Tab) => void;
}) {
  return (
    <div
      style={{
        display: "flex",
        alignItems: "center",
        gap: 6,
        border: "1px solid #ccc",
        padding: "4px 6px",
      }}
    >
      {/* ‚úÖ ZONE DRAG UNIQUEMENT */}
      <div
        draggable
        onDragStart={(e) => {
          e.dataTransfer.setData(
            "application/x-mosaic-tab",
            JSON.stringify({
              tabId: tab.id,
              sourceContainerId: containerId,
            })
          );
          e.dataTransfer.effectAllowed = "move";
        }}
        style={{
          flex: 1,
          cursor: "grab",
          userSelect: "none",
        }}
      >
        Tab {tab.id}
      </div>

      {/* ACTIONS */}
      <button aria-label="Detach tab" onClick={() => onDetach(tab)}>detach</button>
      <button aria-label="Close tab" onClick={() => onClose(tab.id)}>√ó</button>
    </div>
  );
}
=====> src/ui/WorkspaceView.tsx :
import { useState, type DragEvent } from "react";
import type { Workspace } from "../model/workspace";
import { closeTab } from "../model/workspace";
import { handleTabDrop } from "../model/dnd";
import { TabView } from "./TabView";
import { detachPanel } from "../model/workspace.panels";

/**
 * Props du WorkspaceView
 * - workspace : √©tat m√©tier courant
 * - onChange : callback unique pour appliquer une transition m√©tier
 */
type Props = {
  workspace: Workspace;
  onChange: (ws: Workspace) => void;
};

/**
 * MIME type utilis√© pour le Drag & Drop des tabs
 * (√©vite les collisions avec d'autres DnD √©ventuels)
 */
const MIME = "application/x-mosaic-tab";

/**
 * Payload transport√© pendant le drag d'un tab
 */
type DragPayload = {
  tabId: string;
  sourceContainerId: string;
};

/**
 * Helper pour lire proprement le payload DnD
 */
function readDragPayload(e: DragEvent): DragPayload | null {
  const raw = e.dataTransfer.getData(MIME);
  if (!raw) return null;
  try {
    return JSON.parse(raw) as DragPayload;
  } catch {
    return null;
  }
}

export function WorkspaceView({ workspace, onChange }: Props) {
  // ‚úÖ Hooks : uniquement ici, au niveau racine du composant
  const [dragOverContainer, setDragOverContainer] =
    useState<string | null>(null);

  const containers = Object.values(workspace.containers);

  return (
    /**
     * ===============================
     * ZONE "OUTSIDE" GLOBALE
     * ===============================
     *
     * - Drop ici = intention "DETACH"
     * - Le mod√®le d√©cidera :
     *   - isolation (nouveau container)
     *   - ou fermeture (fallback)
     */
    <div
      style={{
        display: "flex",
        gap: 16,
        padding: 16,
        minHeight: 400,
        background: "#f0f0f0",
      }}
      onDragOver={(e) => {
        if (e.dataTransfer.types.includes(MIME)) {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        }
      }}
      onDrop={(e) => {
        const payload = readDragPayload(e);
        if (!payload) return;

        // üëâ MOVE TAB ‚Üí OUTSIDE = DETACH
        onChange(
          handleTabDrop(workspace, payload.tabId, {
            type: "outside",
          })
        );
      }}
    >
      {containers.map((container) => (
        /**
         * ===============================
         * CONTAINER (DROP ZONE "GROUPER")
         * ===============================
         *
         * - Drop n'importe o√π dans le panel
         *   = groupement dans ce container
         */
        <div
          key={container.id}
          style={{
            border: "1px solid #ccc",
            padding: 8,
            minWidth: 240,
            background:
              dragOverContainer === container.id
                ? "#e6f2ff"
                : "#fafafa",
          }}
          onDragOver={(e) => {
            if (e.dataTransfer.types.includes(MIME)) {
              e.preventDefault();
              e.dataTransfer.dropEffect = "move";
            }
          }}
          onDragEnter={() => setDragOverContainer(container.id)}
          onDrop={(e) => {
            // ‚ö†Ô∏è Emp√™che le drop "outside" global
            e.stopPropagation();
            setDragOverContainer(null);

            const payload = readDragPayload(e);
            if (!payload) return;

            // Optionnel : ignorer le drop sur le m√™me container
            if (payload.sourceContainerId === container.id) {
              return;
            }

            onChange(
              handleTabDrop(workspace, payload.tabId, {
                type: "header",
                containerId: container.id,
              })
            );
          }}
        >
          {/* ===============================
              HEADER DU CONTAINER (VISUEL)
              =============================== */}
          <div
            style={{
              padding: 6,
              border: "1px dashed #bbb",
              marginBottom: 8,
              background: "#fff",
            }}
          >
            <h3 style={{ margin: 0 }}>
              Container {container.id}
            </h3>
          </div>

          {/* ===============================
              LISTE DES TABS
              =============================== */}
          {container.tabs.map((tab) => (
            <div
              key={tab.id}
              style={{
                border: "1px solid #ddd",
                padding: 6,
                marginBottom: 8,
                background: "#fff",
              }}
            >
              {/* -------------------------------
                  TAB (DRAG + CLOSE)
                  -------------------------------
                  - Drag = d√©placement
                  - ‚úï = fermeture explicite
               */}
              <TabView
                tab={tab}
                containerId={container.id}
                onClose={(tabId) =>
                  onChange(closeTab(workspace, tabId))
                }
                onDetach={(tab) => {
                  const { workspace: next } = detachPanel(workspace, tab);
                  onChange(next);
                }}
              />
            </div>
          ))}
        </div>
      ))}
    </div>
  );
}
=====> src/ui/__tests__/Workspace.detach.spec.tsx :
import { render, screen, fireEvent } from "@testing-library/react";
import { describe, it, expect } from "vitest";
import { useState } from "react";
import type { Workspace } from "../../model/workspace";
import type { Container } from "../../model/container";
import type { Tab } from "../../model/tab";
import { WorkspaceView } from "../WorkspaceView";

function initialWorkspace(): Workspace {
  const A: Tab = { id: "A", kind: "test" };
  const B: Tab = { id: "B", kind: "test" };
  const C1: Container = { id: "C1", tabs: [A, B] };
  return { containers: { C1 } };
}

function TestHost() {
  const [workspace, setWorkspace] =
    useState<Workspace>(initialWorkspace());

  return (
    <WorkspaceView
      workspace={workspace}
      onChange={setWorkspace}
    />
  );
}

describe("WorkspaceView ‚Äî Detach (UI)", () => {
  it("retire le tab du workspace quand on clique sur detach", () => {
    render(<TestHost />);

    // Pr√©condition
    expect(screen.getByText("Tab A")).toBeTruthy();
    expect(screen.getByText("Tab B")).toBeTruthy();

    // Action : click sur le bouton DETACH du tab A
    const detachButtons = screen.getAllByLabelText("Detach tab");
    fireEvent.click(detachButtons[0]);

    // R√©sultat
    expect(screen.queryByText("Tab A")).toBeNull();
    expect(screen.getByText("Tab B")).toBeTruthy();
  });
});
=====> src/ui/__tests__/Workspace.isolate.spec.tsx :
import { describe, it, expect } from "vitest";
import { render, fireEvent } from "@testing-library/react";
import { WorkspaceView } from "../WorkspaceView";
import type { Workspace } from "../../model/workspace";
import type { Container } from "../../model/container";
import type { Tab } from "../../model/tab";

/* Helpers */
function tab(id: string): Tab {
  return { id, kind: "test" };
}
function container(id: string, tabs: Tab[]): Container {
  return { id, tabs };
}
function workspace(containers: Container[]): Workspace {
  return {
    containers: Object.fromEntries(
      containers.map(c => [c.id, c])
    ),
  };
}

it("DnD outside isole le tab si le container a > 1 tab", () => {
    const ws = workspace([
      container("C1", [tab("A"), tab("B")]),
    ]);
  
    let nextWs: Workspace | undefined;
  
    render(
      <WorkspaceView
        workspace={ws}
        onChange={(w) => (nextWs = w)}
      />
    );
  
    // üëâ Simule un drop "outside" sur le tab A
    fireEvent.drop(
      document.querySelector("[style*='background: rgb(240, 240, 240)']")!,
      {
        dataTransfer: {
          getData: () =>
            JSON.stringify({
              tabId: "A",
              sourceContainerId: "C1",
            }),
          types: ["application/x-mosaic-tab"],
        },
      }
    );
  
    expect(nextWs).toBeDefined();
  
    const containers = Object.values(nextWs!.containers);
  
    // ‚ûú un container de plus
    expect(containers.length).toBe(2);
  
    const cWithA = containers.find(c =>
      c.tabs.some(t => t.id === "A")
    )!;
    const cWithB = containers.find(c =>
      c.tabs.some(t => t.id === "B")
    )!;
  
    expect(cWithA.tabs.map(t => t.id)).toEqual(["A"]);
    expect(cWithB.tabs.map(t => t.id)).toEqual(["B"]);
  });

  it("DnD outside est un no-op si le container a 1 seul tab", () => {
    const ws = workspace([
      container("C1", [tab("A")]),
    ]);
  
    let nextWs: Workspace | undefined;
  
    render(
      <WorkspaceView
        workspace={ws}
        onChange={(w) => (nextWs = w)}
      />
    );
  
    // üëâ drop outside sur A
    fireEvent.drop(
      document.querySelector("[style*='background: rgb(240, 240, 240)']")!,
      {
        dataTransfer: {
          getData: () =>
            JSON.stringify({
              tabId: "A",
              sourceContainerId: "C1",
            }),
          types: ["application/x-mosaic-tab"],
        },
      }
    );
  
    // ‚ûú aucune transition
    expect(nextWs).toBeUndefined();
  });
  
  =====> src/ui/__tests__/Workspace.semantic.spec.tsx :
=====> src/ui/__tests__/Workspace.close.spec.tsx :
import { describe, it, expect } from "vitest";
import { render, waitFor, screen, fireEvent } from "@testing-library/react";
import { useState } from "react";
import { WorkspaceView } from "../WorkspaceView";
import type { Workspace } from "../../model/workspace";
import type { Container } from "../../model/container";
import type { Tab } from "../../model/tab";

/* ======================================================
 * Helpers
 * ====================================================== */

function tab(id: string): Tab {
    return { id, kind: "test" };
}

function container(id: string, tabs: Tab[]): Container {
    return { id, tabs };
}

function workspace(containers: Container[]): Workspace {
    return {
        containers: Object.fromEntries(
            containers.map(c => [c.id, c])
        ),
    };
}

/* ======================================================
 * Test Host (STATEFUL)
 * ====================================================== */

function TestHost({ initial }: { initial: Workspace }) {
    const [ws, setWs] = useState(initial);
    return (
        <WorkspaceView
            workspace={ws}
            onChange={setWs}
        />
    );
}

/* ======================================================
 * Tests
 * ====================================================== */

describe("WorkspaceView ‚Äî Close (UI)", () => {
    it("retire le tab du workspace quand on clique sur ‚úï", () => {
        render(
            <TestHost
                initial={workspace([
                    container("C1", [tab("A"), tab("B")]),
                ])}
            />
        );

        // Pr√©condition
        expect(screen.getByText("Tab A")).toBeDefined();
        expect(screen.getByText("Tab B")).toBeDefined();

        // Action
        const closeButtons = screen.getAllByLabelText("Close tab");
        fireEvent.click(closeButtons[0]);

        // Post-condition DOM
        expect(screen.queryByText("Tab A")).toBeNull();
        expect(screen.getByText("Tab B")).toBeDefined();
    });

    it.skip("retire le dernier tab quand on clique sur ‚úï", async () => {
        render(
          <TestHost
            initial={workspace([
              container("C1", [tab("A")]),
            ])}
          />
        );
      
        fireEvent.click(
          screen.getAllByLabelText("Close tab")[0]
        );
      
        await waitFor(() => {
          expect(screen.queryByText("Tab A")).toBeNull();
        });
      });
      
});
=====> src/ui/__tests__/Workspace.render.spec.tsx :
=====> src/ui/WorkspaceMosaicView.tsx :
// src/ui/WorkspaceMosaicView.tsx

import { useState, useEffect } from "react";
import {
  Mosaic,
  MosaicWindow,
  type MosaicNode,
} from "react-mosaic-component";

import type { Workspace } from "../model/workspace";
import type { Container } from "../model/container";
import { ContainerView } from "./ContainerView";

/* ======================================================
 * Types
 * ====================================================== */

// Phase 0 : 1 container m√©tier = 1 node Mosaic
type MosaicLayout = MosaicNode<string>;

/* ======================================================
 * Utils ‚Äî layout minimal
 * ====================================================== */

/**
 * G√©n√®re un layout Mosaic minimal √† partir des containers.
 * - 0 container ‚Üí null
 * - 1 container ‚Üí leaf
 * - n containers ‚Üí split lin√©aire (ordre arbitraire)
 *
 * ‚ö†Ô∏è Aucune promesse de direction / position
 */
function buildInitialLayout(containerIds: string[]): MosaicLayout | null {
  if (containerIds.length === 0) {
    return null;
  }

  if (containerIds.length === 1) {
    return containerIds[0];
  }

  return containerIds.slice(1).reduce<MosaicLayout>(
    (acc, id) => ({
      direction: "row",
      first: acc,
      second: id,
    }),
    containerIds[0]
  );
}

/* ======================================================
 * Component
 * ====================================================== */

export function WorkspaceMosaicView({
  workspace,
  onWorkspaceChange,
}: {
  workspace: Workspace;
  onWorkspaceChange: (next: Workspace) => void;
}) {
  const containerIds = Object.keys(workspace.containers);

  /**
   * UI state pur : layout Mosaic
   * ‚ö†Ô∏è D√âRIV√â du workspace, jamais source de v√©rit√©
   */
  const [layout, setLayout] = useState<MosaicLayout | null>(() =>
    buildInitialLayout(containerIds)
  );

  /**
   * üîí R√®gle Phase Mosaic 0
   * Si les containers changent, on reconstruit le layout.
   * (brutal mais sain √† ce stade)
   */
  useEffect(() => {
    setLayout(buildInitialLayout(containerIds));
  }, [containerIds.join("|")]);

  /**
   * onChange(layout)
   * ‚Üí g√©om√©trie UNIQUEMENT
   * ‚Üí aucun impact m√©tier
   */
  const handleLayoutChange = (nextLayout: MosaicLayout | null) => {
    setLayout(nextLayout);
  };

  /**
   * onRemove(containerId)
   * ‚Üí fermeture visuelle
   * ‚Üí PAS un detach
   */
  const handleRemove = (containerId: string) => {
    if (!workspace.containers[containerId]) return;

    onWorkspaceChange({
      ...workspace,
      containers: Object.fromEntries(
        Object.entries(workspace.containers).filter(
          ([id]) => id !== containerId
        )
      ),
    });
  };

  /**
   * Rendu d‚Äôun container
   * Mosaic ne conna√Æt QUE les containers
   */
  const renderTile = (containerId: string, path: any) => {
    const container: Container | undefined =
      workspace.containers[containerId];

    if (!container) {
      return null;
    }

    return (
      <MosaicWindow<string>
        path={path}
        title={`Container ${containerId}`}
        onRemove={() => handleRemove(containerId)}
      >
        <ContainerView
          workspace={workspace}
          container={container}
          onWorkspaceChange={onWorkspaceChange}
        />
      </MosaicWindow>
    );
  };

  return (
    <Mosaic<string>
      value={layout}
      onChange={handleLayoutChange}
      renderTile={renderTile}
    />
  );
}
=====> src/ui/ContainerView.tsx :
// src/ui/ContainerView.tsx

import { useState, type DragEvent } from "react";
import type { Container } from "../model/container";
import type { Workspace } from "../model/workspace";
import { closeTab } from "../model/workspace";
import { handleTabDrop } from "../model/dnd";
import { detachPanel } from "../model/workspace.panels";
import { TabView } from "./TabView";

/**
 * MIME type utilis√© pour le Drag & Drop des tabs
 */
const MIME = "application/x-mosaic-tab";

/**
 * Payload transport√© pendant le drag d'un tab
 */
type DragPayload = {
  tabId: string;
  sourceContainerId: string;
};

/**
 * Helper pour lire le payload DnD
 */
function readDragPayload(e: DragEvent): DragPayload | null {
  const raw = e.dataTransfer.getData(MIME);
  if (!raw) return null;
  try {
    return JSON.parse(raw) as DragPayload;
  } catch {
    return null;
  }
}

export function ContainerView({
  workspace,
  container,
  onWorkspaceChange,
}: {
  workspace: Workspace;
  container: Container;
  onWorkspaceChange: (next: Workspace) => void;
}) {
  const [dragOver, setDragOver] = useState(false);

  return (
    <div
      className="container-panel"
      style={{
        border: "1px solid #ccc",
        padding: 8,
        minWidth: 240,
        background: dragOver ? "#e6f2ff" : "#fafafa",
        height: "100%",
        boxSizing: "border-box",
      }}
      onDragOver={(e) => {
        if (e.dataTransfer.types.includes(MIME)) {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
        }
      }}
      onDragEnter={() => setDragOver(true)}
      onDragLeave={() => setDragOver(false)}
      onDrop={(e) => {
        // ‚ö†Ô∏è Emp√™che le drop "outside" global
        e.stopPropagation();
        setDragOver(false);

        const payload = readDragPayload(e);
        if (!payload) return;

        // ignorer le drop sur le m√™me container
        if (payload.sourceContainerId === container.id) {
          return;
        }

        onWorkspaceChange(
          handleTabDrop(workspace, payload.tabId, {
            type: "header",
            containerId: container.id,
          })
        );
      }}
    >
      {/* ===============================
          HEADER DU CONTAINER
         =============================== */}
      <div
        style={{
          padding: 6,
          border: "1px dashed #bbb",
          marginBottom: 8,
          background: "#fff",
        }}
      >
        <h3 style={{ margin: 0 }}>Container {container.id}</h3>
      </div>

      {/* ===============================
          LISTE DES TABS
         =============================== */}
      {container.tabs.map((tab) => (
        <div
          key={tab.id}
          style={{
            border: "1px solid #ddd",
            padding: 6,
            marginBottom: 8,
            background: "#fff",
          }}
        >
          <TabView
            tab={tab}
            containerId={container.id}
            onClose={(tabId) =>
              onWorkspaceChange(closeTab(workspace, tabId))
            }
            onDetach={(tab) => {
              const { workspace: next } = detachPanel(workspace, tab);
              onWorkspaceChange(next);
            }}
          />
        </div>
      ))}
    </div>
  );
}
=====> src/App.tsx :
import { useState } from "react";
import type { Workspace } from "./model/workspace";
import type { Container } from "./model/container";
import type { Tab } from "./model/tab";
import { WorkspaceMosaicView } from "./ui/WorkspaceMosaicView";

function initialWorkspace(): Workspace {
  const A: Tab = { id: "A", kind: "test" };
  const B: Tab = { id: "B", kind: "test" };
  const C: Tab = { id: "C", kind: "test" };

  const c1: Container = { id: "C1", tabs: [A, B] };
  const c2: Container = { id: "C2", tabs: [C] };

  return {
    containers: {
      C1: c1,
      C2: c2,
    },
  };
}

export default function App() {
  const [workspace, setWorkspace] =
    useState<Workspace>(initialWorkspace);

  return (
    <div style={{ padding: 16 }}>
      <h1>Mosaic 2</h1>

      <WorkspaceMosaicView
        workspace={workspace}
        onChange={setWorkspace}
      />
    </div>
  );
}
=====> src/main.tsx :
import React from "react";
import ReactDOM from "react-dom/client";
import App from "./App";

ReactDOM.createRoot(
  document.getElementById("root")!
).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);=====> src/setupTests.ts :
import '@testing-library/jest-dom/vitest';

