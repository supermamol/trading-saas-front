=====> src/ui/TabView.tsx :
import type { Tab } from "../model/tab";

export function TabView({ tab }: { tab: Tab }) {
  return (
    <div className="tab-view-content">
      <h4>Contenu du Tab {tab.id}</h4>
      <p>Ici viendra le contenu mÃ©tier spÃ©cifique Ã  ce tab.</p>
      <div className="tab-view-placeholder">
        Charts / forms / lists / etc.
      </div>
    </div>
  );
}
=====> src/ui/WorkspaceMosaicView.tsx :
import {
    Mosaic,
    MosaicWindow,
    type MosaicNode,
  } from "react-mosaic-component";
  
  import type { Workspace } from "../model/workspace";
  import type { Container } from "../model/container";
  import { activateTab } from "../model/container";
  import { closeTab } from "../model/workspace";
  import { detachPanel } from "../model/workspace.panels";
  import { ContainerView } from "./ContainerView";
  
  /* ======================================================
   * Types
   * ====================================================== */
  export type Layout = MosaicNode<string>;
  
  export type WorkspaceState = {
    workspace: Workspace;
    layout: MosaicNode<string> | null;
  };
  
  type Props = {
    state: WorkspaceState;
    onStateChange: (updater: (s: WorkspaceState) => WorkspaceState) => void;
    hoveredContainerId: string | null; // ðŸ‘ˆ AJOUT
  };
    
  /* ======================================================
   * Utils
   * ====================================================== */
  export function buildInitialLayout(containerIds: string[]): Layout | null {
    if (containerIds.length === 0) return null;
    if (containerIds.length === 1) return containerIds[0];
  
    return containerIds.slice(1).reduce<Layout>(
      (acc, id) => ({
        direction: "row",
        first: acc,
        second: id,
      }),
      containerIds[0]
    );
  }
  
  function pruneLayout(
    node: MosaicNode<string> | null,
    validIds: Set<string>
  ): MosaicNode<string> | null {
    if (!node) return null;
  
    if (typeof node === "string") {
      return validIds.has(node) ? node : null;
    }
  
    const first = pruneLayout(node.first, validIds);
    const second = pruneLayout(node.second, validIds);
  
    if (!first && !second) return null;
    if (!first) return second;
    if (!second) return first;
  
    return { ...node, first, second };
  }
  
  /* ======================================================
   * Component
   * ====================================================== */
  export function WorkspaceMosaicView({
    state,
    onStateChange,
    hoveredContainerId,
  }: Props) {
    const { workspace, layout } = state;
  
    /* Layout change = gÃ©omÃ©trie uniquement */
    const handleLayoutChange = (next: Layout | null) => {
      onStateChange(s => ({ ...s, layout: next }));
    };
  
    /* Suppression visuelle dâ€™un container (Mosaic âœ•)
       âš ï¸ PAS un detach mÃ©tier */
    const handleRemove = (containerId: string) => {
      onStateChange(s => ({
        ...s,
        layout: pruneLayout(
          s.layout,
          new Set(
            Object.keys(s.workspace.containers)
              .filter(id => id !== containerId)
          )
        ),
      }));
    };
  
    /* Rendu dâ€™un tile */
    const renderTile = (containerId: string, path: any) => {
      const container: Container | undefined =
        workspace.containers[containerId];
  
      if (!container) {
        return (
          <MosaicWindow<string> path={path} title={null}>
            <div />
          </MosaicWindow>
        );
      }
  
      return (
        <MosaicWindow<string>
          path={path}
          onRemove={() => handleRemove(containerId)}
          renderToolbar={(props) => (
            <div
              className="my-toolbar"
              style={{
                display: "flex",
                alignItems: "center",
                justifyContent: "space-between",
                width: "100%",
                padding: "0 6px",
              }}
            >
              <span>{`Container ${containerId}`}</span>
              {props.onRemove && (
                <button onClick={props.onRemove}>Ã—</button>
              )}
            </div>
          )}
        >
          <ContainerView
            container={container}
            hoveredContainerId={hoveredContainerId} 
              
            /* =============================
             * SELECT TAB (CU)
             * ============================= */
            onSelectTab={(containerId, tabId) =>
              onStateChange((s) => {
                const container = s.workspace.containers[containerId];
                const nextContainer = activateTab(container, tabId);
  
                return {
                  ...s,
                  workspace: {
                    ...s.workspace,
                    containers: {
                      ...s.workspace.containers,
                      [containerId]: nextContainer,
                    },
                  },
                };
              })
            }
  
            /* =============================
             * CLOSE TAB (CU)
             * ============================= */
            onCloseTab={(tabId) =>
              onStateChange((s) => {
                const nextWorkspace = closeTab(s.workspace, tabId);
                const validIds = new Set(Object.keys(nextWorkspace.containers));
  
                return {
                  ...s,
                  workspace: nextWorkspace,
                  layout: pruneLayout(s.layout, validIds),
                };
              })
            }
  
            /* =============================
             * DETACH TAB (CU)
             * ============================= */
            onDetachTab={(tab) =>
              onStateChange((s) => {
                const { workspace: nextWs } = detachPanel(s.workspace, tab);
                const validIds = new Set(Object.keys(nextWs.containers));
  
                return {
                  ...s,
                  workspace: nextWs,
                  layout: pruneLayout(s.layout, validIds),
                };
              })
            }
          />
        </MosaicWindow>
      );
    };
  
    const validIds = new Set(Object.keys(workspace.containers));
    const effectiveLayout = pruneLayout(layout, validIds);
  
    return (
      <Mosaic<string>
        value={effectiveLayout}
        onChange={handleLayoutChange}
        renderTile={renderTile}
      />
    );
  }
  =====> src/ui/ContainerView.tsx :
import { useDroppable, useDndContext } from "@dnd-kit/core";
import type { Container } from "../model/container";
import type { Tab } from "../model/tab";
import { ContainerHeaderView } from "./ContainerHeaderView";
import { TabView } from "./TabView";

export function ContainerView({
  container,
  hoveredContainerId,
  onSelectTab,
  onCloseTab,
  onDetachTab,
}: Props) {
  const { setNodeRef } = useDroppable({
    id: `container-${container.id}`,
    data: {
      type: "container",
      containerId: container.id,
    },
  });

  const { active } = useDndContext();
  const isDraggingTab =
    active?.data.current?.type === "tab";

  const isHovered = hoveredContainerId === container.id;

  const activeTab = container.tabs[container.tabs.length - 1];

  return (
    <div
      ref={setNodeRef}
      className="container-root"
      style={{
        display: "flex",
        flexDirection: "column",
        height: "100%",

        background: isDraggingTab ? "#e6f2ff" : "#fafafa",
        outline: isDraggingTab
          ? isHovered
            ? "2px solid #2563eb"     // ðŸ”µ container survolÃ©
            : "2px dashed #3b82f6"   // ðŸ”· droppable
          : "none",

        outlineOffset: "-2px",
        transition: "background 0.15s, outline 0.15s",
      }}
    >
      <ContainerHeaderView
        tabs={container.tabs}
        activeTab={activeTab}
        containerId={container.id}
        onSelectTab={(tabId) =>
          onSelectTab(container.id, tabId)
        }
        onDetachTab={onDetachTab}
        onCloseTab={onCloseTab}
      />

      <div className="container-panel" style={{ flex: 1 }}>
        <TabView tab={activeTab} />
      </div>
    </div>
  );
}
=====> src/ui/WorkspaceDnDProvider.tsx :
import {
  DndContext,
  DragOverlay,
  type DragEndEvent,
  type DragMoveEvent,
} from "@dnd-kit/core";
import { useState, type ReactNode } from "react";
import type { Workspace } from "../model/workspace";
import { moveTab } from "../model/workspace.move";

type Props = {
  state: { workspace: Workspace };
  onStateChange: (updater: (s: any) => any) => void;
  children: (hoveredContainerId: string | null) => ReactNode;
};

export function WorkspaceDnDProvider({
  state,
  onStateChange,
  children,
}: Props) {
  const [hoveredContainerId, setHoveredContainerId] =
    useState<string | null>(null);

  function handleDragMove(event: DragMoveEvent) {
    const overData = event.over?.data.current;

    if (overData?.type === "container") {
      setHoveredContainerId(overData.containerId);
    } else {
      setHoveredContainerId(null);
    }
  }

  function handleDragEnd(event: DragEndEvent) {
    setHoveredContainerId(null);

    const { active, over } = event;
    if (!over) return;

    const activeData = active.data.current;
    const overData = over.data.current;

    if (
      activeData?.type !== "tab" ||
      overData?.type !== "container"
    ) {
      return;
    }

    const tabId = activeData.tabId;
    const fromContainerId = activeData.fromContainerId;
    const toContainerId = overData.containerId;

    if (fromContainerId === toContainerId) return;

    onStateChange((s: any) => ({
      ...s,
      workspace: moveTab(s.workspace, tabId, toContainerId),
    }));
  }

  return (
    <DndContext
      onDragMove={handleDragMove}
      onDragEnd={handleDragEnd}
      onDragCancel={() => setHoveredContainerId(null)}
    >
      {children(hoveredContainerId)}

      <DragOverlay dropAnimation={null}>
        <div
          className="tab tab--active tab--overlay"
          style={{
            pointerEvents: "none", // ðŸ”¥ CRUCIAL
            padding: "4px 8px",
            background: "white",
            border: "1px solid #3b82f6",
            borderRadius: 4,
            boxShadow: "0 6px 18px rgba(0,0,0,0.2)",
            cursor: "grabbing",
          }}
        >
          Tab
        </div>
      </DragOverlay>
    </DndContext>
  );
}
=====> src/ui/mosaicLayout.ts :
import type { MosaicNode, MosaicParent } from "react-mosaic-component";

export function splitLayoutAtPath(
  layout: MosaicNode<string> | null,
  targetId: string,
  newId: string,
  direction: "row" | "column",
  insert: "before" | "after"
): MosaicNode<string> {
  if (!layout) return layout;

  // remplace la 1Ã¨re occurrence de targetId dans l'arbre
  const replace = (node: MosaicNode<string>): MosaicNode<string> => {
    if (node === targetId) {
      const first = insert === "before" ? newId : targetId;
      const second = insert === "before" ? targetId : newId;
      return { direction, first, second } as MosaicParent<string>;
    }
    if (typeof node === "string") return node;

    return {
      ...node,
      first: replace(node.first),
      second: replace(node.second),
    } as MosaicParent<string>;
  };

  return replace(layout);
}
=====> src/ui/ContainerHeaderView.tsx :
import { useRef } from "react";
import type { Tab } from "../model/tab";
import { XorTab } from "./XorTab";

type Props = {
  tabs: Tab[];
  activeTab: Tab;
  containerId: string;
  onSelectTab: (tabId: string) => void;
  onDetachTab: (tab: Tab) => void;
  onCloseTab: (tabId: string) => void;
};

export function ContainerHeaderView({
  tabs,
  activeTab,
  containerId,
  onSelectTab,
  onDetachTab,
  onCloseTab,
}: Props) {

  // âœ… ORDRE VISUEL STABLE (snapshot initial)
  const orderedTabsRef = useRef<string[]>(
    tabs.map(t => t.id)
  );

  // ðŸ” synchronise si nouveaux tabs (open / close)
  orderedTabsRef.current = orderedTabsRef.current.filter(id =>
    tabs.some(t => t.id === id)
  );
  tabs.forEach(t => {
    if (!orderedTabsRef.current.includes(t.id)) {
      orderedTabsRef.current.push(t.id);
    }
  });

  const orderedTabs = orderedTabsRef.current
    .map(id => tabs.find(t => t.id === id)!)
    .filter(Boolean);

  return (
    <div className="container-header">
      <div className="tablist">
        {orderedTabs.map((tab) => (
          <XorTab
            key={tab.id}
            tabId={tab.id}
            containerId={containerId}
            isActive={tab.id === activeTab.id}
            onSelect={() => onSelectTab(tab.id)}
          />
        ))}
      </div>

      <div className="tab-actions">
        <button onClick={() => onDetachTab(activeTab)}>detach</button>
        <button onClick={() => onCloseTab(activeTab.id)}>Ã—</button>
      </div>
    </div>
  );
}
=====> src/ui/XorTab.tsx :
import { useDraggable } from "@dnd-kit/core";

type Props = {
  tabId: string;
  containerId: string;
  isActive: boolean;
  onSelect: () => void;
};

export function XorTab({ tabId, containerId, isActive, onSelect }: Props) {
  const { setNodeRef, listeners, attributes, transform } = useDraggable({
    id: `tab-${tabId}`,
    data: { type: "tab", tabId, fromContainerId: containerId },
    disabled: !isActive,                 // âœ… XOR robuste
    activationConstraint: { distance: 5 } // âœ… Ã©vite les micro-drags
  });

  return (
    <div
      ref={setNodeRef}
      className={`tab ${isActive ? "tab--active" : ""}`}
      // âœ… click toujours OK ; si actif => Ã§a ne change rien, si inactif => select
      onClick={() => {
        if (!isActive) onSelect();
      }}
      // âœ… listeners/attributes uniquement utiles si actif (car disabled sinon)
      {...listeners}
      {...attributes}
      style={{
        cursor: isActive ? "grab" : "pointer",
        transform: transform
          ? `translate3d(${transform.x}px, ${transform.y}px, 0)`
          : undefined,
      }}
    >
      {tabId}
    </div>
  );
}

